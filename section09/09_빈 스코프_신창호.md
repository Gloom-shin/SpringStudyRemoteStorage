
# 스프링의 강의 리뷰📽
> LoadMap Part : 스프링 핵심원리 - 기본편   
> Section : 09.빈 스코프  
> CreateDate : 2022.06.22  
> UpdateDate : 2022.06

### 목차

- [빈 스코프란?](#beanScope)
- [프로토타입 스코프](#prototype)
    - [싱글톤 빈과 함께 사용시 문제점](#problem)
    - Provider로 문제 해결
- 웹 스코프
- Request 스코프 예제 만들기
- 스코프와 Provider
- 스코프와 프록시
  <br></br>
  <br></br>

# 1. 빈 스코프(Bean Scope)란?<a name="beanScope"></a>
- 뜻 그대로 Bean의 범위를 말하는데,
- 빈의 범위란?
    - 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때까지 빈이 존재할 수 있는 범위를 뜻한다.

### 스코프 종류
스프링은 다음과 같은 다양한 스코프를 지원한다.
- 싱글톤 : 스프링 빈을 생성하면 적용되는 기본적인 스코프이며, 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
- 프로토타입 : 이름에서부터 느껴지듯이, 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
- 웹관련 스코프
    - request : 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
    - session : 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
    - application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프

### 사용 방법
- 자동 등록
    - @Component 위에 추가하면, 스캔할 때 등록된다.
 ```java
@Scope("prototype")
@Component
public class HelloBean {}
```
- 수동 등록
    - @Bean 위에 추가하면, 빈이 등록될 때 같이 된다.
 ```java
@Scope("prototype")
@Bean
PrototypeBean HelloBean() {
 return new HelloBean();
}
```
<br></br>
<br></br>

# 프로토타입 스코프<a name="prototype"></a>
- 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다

## 흐름
### 싱글톤 빈 요청
1. 싱글톤 스코프의 빈을 스프링 컨테이너에 요청한다.
2. 컨테이너는 본인이 관리하는 스프링 빈을 반환한다
3. 이후에 스프링 컨테이너에 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈을 반환한다.

### 프로토타입 빈 요청
1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청한다.
2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.
3. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.
4. 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.

<img src="https://user-images.githubusercontent.com/104331549/175200976-b424f35b-8b73-4f4b-a2a4-0f4844d53a7b.png">

```java
public class PrototypeTest {
    @Test
    public void singletonBeanFind(){
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class);
        PrototypeBean prototypeBean1 = ac.getBean(PrototypeBean.class);
        PrototypeBean prototypeBean2 = ac.getBean(PrototypeBean.class);
        System.out.println("prototypeBean1 = " + prototypeBean1);
        System.out.println("prototypeBean2 = " + prototypeBean2);
        Assertions.assertThat(prototypeBean1).isNotSameAs(prototypeBean2);

        ac.close();
    }

    @Scope("prototype")
    static class PrototypeBean{
        @PostConstruct
        public void init(){
            System.out.println("SingletonBean.init");
        }


        @PreDestroy  // 실행되지 않음
        public void close(){
            System.out.println("SingletonBean.close");
        }
    }

}
```

#### 실행결과
```java
PrototypeBean.init
PrototypeBean.init
prototypeBean1 = hello.core.scope.PrototypeTest$PrototypeBean@30e868be
prototypeBean2 = hello.core.scope.PrototypeTest$PrototypeBean@66c92293
org.springframework.context.annotation.AnnotationConfigApplicationContext - 
Closing //org.springframework.context.annotation.AnnotationConfigApplicationContext@47d9a273, started on Thu Jun 23 11:15:20 KST 2022
```
- 프로토타입 스코프의 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드도 실행된다.
- 프로토타입 빈을 2번 조회했으므로 완전히 다른 스프링 빈이 생성되고, 초기화도 2번 실행된 것을 확인할 수 있다
- 프로토타입 빈은 스프링 컨테이너가 생성과 의존관계 주입 그리고 초기화 까지만 관여하고, 더는 관리하지 않는다. 따라서 프로토타입 빈은 스프링 컨테이너가 종료될 때 `@PreDestroy` 같은 종료 메서드가 전혀 실행되지 않는다
<br></br>
<br></br>
## 싱글톤 빈과 함께 사용시 문제점 <a name="problem"></a>

## 느낀점 😌

### 참고 링크

